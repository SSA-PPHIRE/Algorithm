## 5247. [파이썬 S/W 문제해결 구현] 6일차 - 연산

자연수 N에 몇 번의 연산을 통해 다른 자연수 M을 만들려고 한다.

사용할 수 있는 연산이 +1, -1, *2, -10 네 가지라고 할 때 최소 몇 번의 연산을 거쳐야 하는지 알아내는 프로그램을 만드시오.

단, 연산의 중간 결과도 항상 백만 이하의 자연수여야 한다.

예를 들어 N=2, M=7인 경우, (2+1) *2 +1 = 7이므로 최소 3번의 연산이 필요한다.


**[입력]**

첫 줄에 테스트 케이스의 개수가 주어지고, 다음 줄부터 테스트 케이스 별로 첫 줄에 N과 M이 주어진다. 1<=N, M<=1,000,000, N!=M

**[출력]**

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.



```python
from collections import deque
def sol():
    while q:
        num, cnt = q.popleft()

        if num == m:
            return cnt

        for c in calc:
            cur_num = c(num)

            if 1 <= cur_num <= 1000000:
                if not v[cur_num]:
                    v[cur_num] = 1
                    q.append((cur_num, cnt+1))


for tc in range(1, int(input())+1):

    n, m = map(int, input().split())
    calc = [lambda x:x+1, lambda x:x-1, lambda x:x*2, lambda x:x-10]

    q = deque([(n, 0)])
    v = [0] * 1000001
    v[n] = 1

    res = sol()

    print(f'#{tc} {res}')
```

```
# input
3
2 7
3 15
36 1007

# output
#1 3
#2 4
#3 8
```

---

- BFS로 접근, dp로 풀수 있을까했는데, 연산과정이 모두 다르기 때문에 dp 배열을 선언하기가 어렵다고 판단..
  - `calc` 리스트에 `lambda`로 4가지 연산을 저장
  - `q` 큐는 연산속도 증가를 위해 `deque` 사용 (사용하지 않으면 제한시간 초과남)
    - 큐에는 숫자와 현재 연산한 횟수를 저장
  - 연산해서 나올 수 있는 모든 수에대해 방문 체크를 확인할 리스트 `v` 선언
  - `sol` 함수 -> bfs 과정
    - 큐에서 원소하나를 pop -> 현재 숫자와 해당 숫자가 나오기까지의 연산횟수를 얻을 수 있음
    - 만약 이때 현재 숫자가 내가 찾던 숫자와 동일하다면 바로 연산횟수를 리턴
    - 그렇지 않다면 `calc` 함수 내부를 순환하며 연산을 진행
    - +1, -1, *2, -10을 한번씩 진행할 것임
    - 이때 유효범위를 초과하면 다음 반복으로 넘어감
    - 유효범위 내라면 내가 이전에 연산을 통해 방문한 숫자인지 확인
      - 만일 방문했던 숫자라면 굳이 다시 연산을 할 필요없음 `q`어딘가에 더 적은 연산횟수의 숫자가 돌고 있을 것임
    - 아직 방문하지 않았다면 큐에 추가하고 해당 과정을 반복