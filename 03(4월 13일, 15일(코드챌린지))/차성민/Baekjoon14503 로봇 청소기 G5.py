#백준 14503 로봇 청소기 G5
# DFS, 시뮬레이션
# 어지간하면 함수를 만들어서 모듈화를 잘하자... 한번에 다 넣으려하니까 꼬임

import sys
sys.stdin = open('text/14503.txt', 'r')
from collections import deque

n, m = map(int, input().split()) #N x M 직사각형
r, c, d = map(int, input().split()) # 로봇 청소기의 (r,c)좌표 , 방향

# 리스트 생성  0: 빈칸 1: 벽 위가 북쪽, 좌측이 서쪽
arr = []
for i in range(n):
    arr.append(list(map(int, input().split())))

''' 규칙
현재 위치를 청소 -> 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행 (우측으로 진행)
왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행
왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 위 과정으로 돌아감.
네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번째 과정으로 돌아간다.(좌측으로 한칸)
네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.(종료 조건)
로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.
'''

# 북: 0, 동: 1, 남: 2, 서 : 3
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]


#bfs 활용하고, 거기에 추가로 왼쪽 방향 회전 관련과 후진관련 내용 적용해보자.
q = deque()

# 큐에 어떤 요소들을 넣어 줄 것인지?  x,y 좌표, 방향은 필수고 거기에 출력을 해주어야 할 칸 개수까지 넣어줌
# 중요 : 청소 칸 개수의 default를 1로하면 벽이랑 같아서 에러남  = > 2로 설정하고 1를 마지막에 뺴자(처음에 자기 자리 청소하므로 1부터니까)
q.append((r, c, d, 2))

res = 0  # 답 위한 변수 선언
while q:
    x, y, d, cnt = q.popleft()
    new_d = d

    #청소 진행부터
    if arr[x][y] == 0: #0이면 청소하고  1이 아닌 다른 값(나는 cnt로)으로 값을 바꿔줌.
        arr[x][y] = cnt

    #청소 진행 후 회전 진행
    for _ in range(4):
        new_d = (new_d + 3) % 4 #북동남서 순으로 만드려면 (현재 방향+ 3) %4가 왼쪽 방향
        nx = x + dx[new_d]
        ny = y + dy[new_d]
        if arr[nx][ny] == 0: # 회전 후 진행한 곳이 청소를 하지 않은곳이면 이동하여 청소 진행하고 break통해서 다시 진행
            q.append((nx, ny, new_d, cnt + 1))
            break

    else: # 네 방위 모두 0이 아닌 경우, 즉 후진을 해줘야 할 때
        back_d = (d + 2) % 4
        nx = x + dx[back_d]
        ny = y + dy[back_d]

        if arr[nx][ny] != 1: #뒤에가 벽이 아니라면 후진
            q.append((nx, ny, d, cnt)) #후진이므로 cnt는 변화 X

    res = cnt - 1 # 처음에 2로 설정했으니까

print(res)
