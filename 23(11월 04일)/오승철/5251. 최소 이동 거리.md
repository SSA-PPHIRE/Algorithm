### 5251. [파이썬 S/W 문제해결 구현] 7일차 - 최소 이동 거리

A도시에는 E개의 일방통행 도로 구간이 있으며, 각 구간이 만나는 연결지점에는 0부터 N번까지의 번호가 붙어있다.

구간의 시작과 끝의 연결 지점 번호, 구간의 길이가 주어질 때, 0번 지점에서 N번 지점까지 이동하는데 걸리는 최소한의 거리가 얼마인지 출력하는 프로그램을 만드시오.

모든 연결 지점을 거쳐가야 하는 것은 아니다.

![image](https://user-images.githubusercontent.com/67505208/139573074-cc76dbbf-18c9-468d-aa20-4b8bd196e812.png)

그림은 입력인 N=2, E=3, 시작과 끝 지점, 구간 거리가 아래와 같은 경우의 예이다.

0 1 1
0 2 6
1 2 1


**[입력]**

첫 줄에 테스트 케이스의 개수 T가 주어지고, 테스트 케이스 별로 첫 줄에 마지막 연결지점 번호N과 도로의 개수 E가 주어진다.

다음 줄부터 E개의 줄에 걸쳐 구간 시작 s, 구간의 끝 지점 e, 구간 거리 w가 차례로 주어진다. ( 1<=T<=50, 1<=N, s, e<=1000, 1<=w<=10, 1<=E<=1000000 )

**[출력]**

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 테스트 케이스에 대한 답을 출력한다.

```
# input
3
2 3
0 1 1
0 2 6
1 2 1
4 7
0 1 9
0 2 3
0 3 7
1 4 2
2 3 8
2 4 1
3 4 8
4 6
0 1 10
0 2 7
1 4 2
2 3 10
2 4 3
3 4 10

# output
#1 2
#2 4
#3 10
```

---

```python
def dijkstra(s, adj):
    sel = [s]
    d = list(adj[s])

    while len(sel) < (n+1):
        min_distance = float('inf')
        index = -1

        for i in range(n+1):
            if d[i] < min_distance and i not in sel:
                min_distance = d[i]
                start = i

        sel.append(start)
        # print(sel)

        for next_v, next_d in enumerate(adj[start]):
            if d[next_v] > d[start] + next_d:
                d[next_v] = d[start] + next_d
        # print(d)
    return d[-1]


for tc in range(1, int(input())+1):
    n, e = map(int, input().split())
    adj = [[float('inf')] * (n+1) for _ in range(n+1)]

    for _ in range(e):
        s, e, w = map(int, input().split())
        adj[s][e] = w

    # for aa in adj:
    #     print(aa)

    print(f'#{tc} {dijkstra(0, adj)}')
```

- 다익스트라 알고리즘 사용
  - 특정 하나의 정점에서 다른 모든 정점으로 가는 최단 거리를 알려주는 알고리즘
  - 시간 복잡도는 O(N^2)
    - 이 때 노드 수는 많지만 비해 간선의 정보가 적다면 힙 구조를 활용해서 시간 복잡도를 O(N log N)까지 낮출 수 있음
  - DP, 그리디를 적용한 알고리즘이라고 할 수 있음
  - 음의 가중치일 때는 적용 불가능



- 인접 행렬 `adj`에 가중치 정보를 최신화
  - 이 때 양방향이 아니므로 대칭으로 정보 입력하는 것 주의
- 0번 정점에서 N번 정점까지의 최소 거리이므로 인자 `s`에는 0, return 값에는 `d[-1]`을 적용
- 모든 정점을 방문하기 까지 순회
  - 최소거리를 무한대로 초기화
  - 0번 정점에서 갈 수 있는 정점들의 가중치를 하나씩 순회하며, **거리가 가장 짧고 아직 방문하지 않은 상태**일 때,해당 정점을 통해 방문할 수 있는 노드를 비교하며 거리배열을 최신화
    - 0번 -> i번 정점을 통해 갈 수 있는 정점의 거리를 비교하며 최소거리 일 때
  - 그 다음 0번 정점에서 갈 수 있는 최소 가중치이며 아직 방문하지 않은 정점에 대한 탐색을 반복,
  - 모든 정점을 이러한 방법으로 탐색이 끝날때까지 완료하면 종료,
  - n번째의 정점까지의 거리인 `d[-1]`을 반환
